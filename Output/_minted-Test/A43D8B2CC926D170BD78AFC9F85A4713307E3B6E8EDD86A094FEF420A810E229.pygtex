\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}ifndef SOLVER\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}define SOLVER\PYGZus{}H}

\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}pch.h\PYGZdq{}}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Solver}
\PYG{p}{\PYGZob{}}
\PYG{k}{protected}\PYG{o}{:}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{iMax}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{jMax}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{SimulationParameters}\PYG{+w}{ }\PYG{n}{parameters}\PYG{p}{;}
\PYG{+w}{    }
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}summary\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// Unflattens the array specified in \PYGZlt{}paramref name=\PYGZdq{}flattenedArray\PYGZdq{} /\PYGZgt{}, storing the result in \PYGZlt{}paramref name=\PYGZdq{}pointerArray\PYGZdq{} /\PYGZgt{}.}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}/summary\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}typeparam name=\PYGZdq{}T\PYGZdq{}\PYGZgt{}The type of the elements in the array.\PYGZlt{}/typeparam\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}pointerArray\PYGZdq{}\PYGZgt{}The output 2D array.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}paDownOffset\PYGZdq{}\PYGZgt{}The number of elements below the region of a column to be copied into the pointer array.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}paLeftOffset\PYGZdq{}\PYGZgt{}The number of elements left of the region of a row to be copied into the pointer array.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}flattenedArray\PYGZdq{}\PYGZgt{}The input flattened array\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}faDownOffset\PYGZdq{}\PYGZgt{}The number of elements below the region of a column to be copied from the flattened array.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}faUpOffset\PYGZdq{}\PYGZgt{}The number of elements above the region of a column to be copied from the flattened array.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}faLeftOffset\PYGZdq{}\PYGZgt{}The number of elements left of the region of a row to be copied from the flattened array.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}xLength\PYGZdq{}\PYGZgt{}The number of elements in the x direction that are to be copied.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}yLength\PYGZdq{}\PYGZgt{}The number of elements in the y direction that are to be copied.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{+w}{    }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{UnflattenArray}\PYG{p}{(}\PYG{n}{T}\PYG{o}{**}\PYG{+w}{ }\PYG{n}{pointerArray}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{paDownOffset}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{paLeftOffset}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{flattenedArray}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{faDownOffset}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{faUpOffset}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{faLeftOffset}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{xLength}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{yLength}\PYG{p}{);}

\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}summary\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// Flattens the 2D array specified in \PYGZlt{}paramref name=\PYGZdq{}pointerArray\PYGZdq{} /\PYGZgt{}, storing the result in \PYGZlt{}paramref name=\PYGZdq{}flattenedArray\PYGZdq{} /\PYGZgt{}.}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}/summary\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}typeparam name=\PYGZdq{}T\PYGZdq{}\PYGZgt{}The type of the elements in the array.\PYGZlt{}/typeparam\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}pointerArray\PYGZdq{}\PYGZgt{}The input 2D array.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}paDownOffset\PYGZdq{}\PYGZgt{}The number of elements below the region of a column to be copied from the pointer array.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}paLeftOffset\PYGZdq{}\PYGZgt{}The number of elements left of the region of a row to be copied from the pointer array.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}flattenedArray\PYGZdq{}\PYGZgt{}The output flattened array\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}faDownOffset\PYGZdq{}\PYGZgt{}The number of elements below the region of a column to be copied into the flattened array.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}faUpOffset\PYGZdq{}\PYGZgt{}The number of elements above the region of a column to be copied into the flattened array.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}faLeftOffset\PYGZdq{}\PYGZgt{}The number of elements left of the region of a row to be copied into the flattened array.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}xLength\PYGZdq{}\PYGZgt{}The number of elements in the x direction that are to be copied.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}yLength\PYGZdq{}\PYGZgt{}The number of elements in the y direction that are to be copied.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{+w}{    }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{FlattenArray}\PYG{p}{(}\PYG{n}{T}\PYG{o}{**}\PYG{+w}{ }\PYG{n}{pointerArray}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{paDownOffset}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{paLeftOffset}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{flattenedArray}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{faDownOffset}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{faUpOffset}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{faLeftOffset}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{xLength}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{yLength}\PYG{p}{);}

\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}summary\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// Initialises the class\PYGZsq{}s fields and parameters}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}/summary\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}parameters\PYGZdq{}\PYGZgt{}The parameters to use for simulation. This may be changed before calls to \PYGZlt{}see cref=\PYGZdq{}Timestep\PYGZdq{} /\PYGZgt{}.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}iMax\PYGZdq{}\PYGZgt{}The index of the rightmost fluid cell\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}jMax\PYGZdq{}\PYGZgt{}The index of the topmost fluid cell\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{n}{Solver}\PYG{p}{(}\PYG{n}{SimulationParameters}\PYG{+w}{ }\PYG{n}{parameters}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{iMax}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{jMax}\PYG{p}{);}

\PYG{+w}{    }\PYG{o}{\PYGZti{}}\PYG{n}{Solver}\PYG{p}{();}

\PYG{+w}{    }\PYG{n}{SimulationParameters}\PYG{+w}{ }\PYG{n+nf}{GetParameters}\PYG{p}{()}\PYG{+w}{ }\PYG{k}{const}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{SetParameters}\PYG{p}{(}\PYG{n}{SimulationParameters}\PYG{+w}{ }\PYG{n}{parameters}\PYG{p}{);}

\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{GetIMax}\PYG{p}{()}\PYG{+w}{ }\PYG{k}{const}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{GetJMax}\PYG{p}{()}\PYG{+w}{ }\PYG{k}{const}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{virtual}\PYG{+w}{ }\PYG{n}{REAL}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{GetHorizontalVelocity}\PYG{p}{()}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{virtual}\PYG{+w}{ }\PYG{n}{REAL}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{GetVerticalVelocity}\PYG{p}{()}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{virtual}\PYG{+w}{ }\PYG{n}{REAL}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{GetPressure}\PYG{p}{()}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{virtual}\PYG{+w}{ }\PYG{n}{REAL}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{GetStreamFunction}\PYG{p}{()}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{o}{**}\PYG{+w}{ }\PYG{n+nf}{GetObstacles}\PYG{p}{()}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}summary\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// Embeds obstacles into the simulation domain. Assumes obstacles have already been set}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}/summary\PYGZgt{}}
\PYG{+w}{    }\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{ProcessObstacles}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}summary\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// Performs setup for executing timesteps. This function must be called once before the first call to \PYGZlt{}c\PYGZgt{}Timestep\PYGZlt{}/c\PYGZgt{}, and after any changes to \PYGZlt{}c\PYGZgt{}parameters\PYGZlt{}/c\PYGZgt{}.}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}/summary\PYGZgt{}}
\PYG{+w}{    }\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{PerformSetup}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}summary\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// Computes one timestep, solving each of the fields.}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}/summary\PYGZgt{}}
\PYG{+w}{    }\PYG{c+c1}{/// \PYGZlt{}param name=\PYGZdq{}simulationTime\PYGZdq{}\PYGZgt{}The time that the simulation has been running, to be updated with the new time after the timestep has finished.\PYGZlt{}/param\PYGZgt{}}
\PYG{+w}{    }\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Timestep}\PYG{p}{(}\PYG{n}{REAL}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{simulationTime}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{};}
\PYG{c+cp}{\PYGZsh{}endif }\PYG{c+c1}{// !SOLVER\PYGZus{}H}
\end{Verbatim}
